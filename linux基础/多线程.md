-----------------------------------
## linux  
linux是用一个pthread_t线程号去创建一个线程：pthread_create(pthread_t,NULL,func,argc).

---------------------------------
## c++       
c++是直接用`std::thread`创建一个对象:`std::thread t1(func,argc)`.可以先`thread t;`声明,然后在某个位置`t=thread();`进行重新赋值。  
用`t.join()`来等待线程结束。  
`静态成员函数`的缺陷是，除非将成员变量声明为静态的，否则在线程函数体内无法使用类内的成员变量。**为了进一步完善这一缺陷，可以使用 Lambda 匿名函数表达式或者 C++11 的函数绑定特性。**  
而一旦成员变量声明为静态的，static 成员变量则必须在**类声明的外部初始化**.  
下面为，在类中使用线程函数，要注意的点：创建线程时传入的函数是静态类成员函数，因此，这个工作函数必须在类内声明，类外定义功能。    
而工作函数中巧妙的规避了使用静态成员变量，原因是传入了一个指向类对象的指针参数，调用指针指向的类对象函数从而可以修改指向该类的普通成员变量。  
```CPP
#include <thread>
#include <mutex>
#include <iostream>
#include <vector>
using namespace std;
class Lock{
private:
    mutex m;
public:
    void lock(){
        m.lock();
    }
    void unlock(){
        m.unlock();
    }
};
//声明
class Solution{
public:
    int num_threads;
    vector<thread> t1;
    Lock m1;
    int a;
    Solution(int n){
        a=0;
        num_threads = n;
        t1.resize(num_threads);
    }
    static void worker(void* argc);
    void dothread(){
        for(int i=0;i<num_threads;i++){
            //循环创建线程
            t1[i] = thread(worker,this);
        }
        for(int i=0;i<num_threads;i++){
            //等待线程结束
            t1[i].join();
        }
    }
    void run(){
        //对a++;
        while(true){
            m1.lock();
            if(a>=100) {
                m1.unlock();
                break;
            }
            a++;
            cout<<endl<<this_thread::get_id()<<" "<<a<<endl;
            m1.unlock();
            this_thread::sleep_for(chrono::seconds(2));
        }
    };
};
void Solution::worker(void* argc){
    Solution* s = (Solution*)argc;
    s->run();
}
int main(){
    
    Solution s(10);
    s.dothread();
    return 0;
}
```
下面是使用lambda函数，用引用捕捉所有外部变量，从而避免定义静态类成员函数作为thread()的参数，并且这么做还可以使用类的普通成员变量、函数。
```CPP
#include <thread>
#include <mutex>
#include <iostream>
#include <vector>
using namespace std;
class Lock{
private:
    mutex m;
public:
    void lock(){
        m.lock();
    }
    void unlock(){
        m.unlock();
    }
};
//声明
class Solution{
public:
    int num_threads;
    vector<thread> t1;
    Lock m1;
    int a;
    Solution(int n){
        a=0;
        num_threads = n;
        t1.resize(num_threads);
    }
    void dothread(){
        auto lamba_func = [&]()->void {
            while(true){
                m1.lock();
                if(a>=100) {
                    m1.unlock();
                    break;
                }
                a++;
                cout<<endl<<this_thread::get_id()<<" "<<a<<endl;
                m1.unlock();
                this_thread::sleep_for(chrono::seconds(2));
            }
        };
        for(int i=0;i<num_threads;i++){
            //循环创建线程
            t1[i] = thread(lamba_func);
        }
        for(int i=0;i<num_threads;i++){
            //等待线程结束
            t1[i].join();
        }
    }

};

int main(){
    Solution s(10);
    s.dothread();
    return 0;
}
```
