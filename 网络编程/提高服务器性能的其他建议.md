* [池](#池)
* [数据复制](#数据复制)
* [上下文切换和锁](#上下文切换和锁)

### 池
提高服务器性能的一个很直接的方法就是以空间换时间。这就是“池”的概念。  
池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源、分配。  
当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它简要相关的资源，就可以直接从池中获取，无须动态分配。  
很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资顿的系统调用都是很耗时的。  
当服务器处理完一个客户连接后， 可以把相关的资源放回池中，无须执行系统调用来释放资源。  
从最终的效巢来看，池相当于服务器管理系统资源的应用层设施， 它避免了服务锦对内核的频繁访问。  

---
池可分为多种：
* 内存池：通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，
我们可以选择丢弃请求或者动态扩大接收缓冲区。  
* 进程池
* 线程池：进程池和线程池都是并发编程常用的伎俩。当我们需要一个工作进程或者工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无需动态的调用fork或
pthread_create 等函数来创建进程和线程。  
* 连接池：通常用于服务器或服务器集群的内部永久连接。每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后
释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。连接吃是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体
并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。

---
### 数据复制
&emsp;&emsp; 高性能服务器应该避免不必要的数据复制，尤其是当数据复制发生在用户代码和内核之间的时候。  
如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区中。  
这里说的“直接处理”指的是应用程序不关心这些数据的内容，不需要对他们做任何分析。  
比如ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件的具体内容。  
这样的话，ftp服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发送给客户端。  
&emsp;&emsp;此外，用户代码内部（不访问内核）的数据复制也是应该避免的。  
举例来说，当两个工作进程之间要传大量的数据时，我们就应该考虑使用共享内存来在他们之间共享这些数据，而不是使用管道或者消息队列来传递。  
又比如解析HTTP请求得实例中，用指针（start_line)来指出每个行在buffer中得起始位置，以便随后对行内容进行访问，而不是把行的内容复制到另一个缓冲区来使用，因为这样既浪费空间，又效率低下。  
  
---
### 上下文切换和锁
* 并发程序必须考虑上下文切换（context switch）问题，即进程切换或线程切换导致的系统开销。即使是IO密集型的服务器，也不应该使用过多的工作线程或进程，否则线程间的切换将占用大量的
cpu时间，服务器真正用于处理业务逻辑的cpu时间的比重就显得不足了。   
因此为每个客户连接都创建一个工作线程的服务器的模型是不可取的。  
半同步/半异步模式是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。当线程的数量不大于CPU数目时，
上下文的切换就不是问题了。
* 并发程序需要考虑的另外一个问题是共享资源的加锁保护。锁通常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。  
因此，服务器如果有更好的解决方案，就应该避免使用锁。  
显然，半同步/半异步模式就比半同步/半反应堆模式的效率高。  
如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用**读写锁**。  
当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存时，系统才必须去锁住这块区域。  




