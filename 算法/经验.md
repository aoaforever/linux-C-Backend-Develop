* 与操作
应用场合：
1. 取一个整数中二进制的最右侧的1。：N &（ ~N +1 ）**经常用到**
 
 
* 异或满足交换律，结合律等。 
应用场合： 
1. 不开辟新变量交换两个变量，缺点，但这两个变量在内存上是同一地址，失效。
2. 一个数组中，只有一种数出现了奇数次，其他数出现了偶数次，找出这个奇数次的数。对数组每个元素进行异或。
3. 一个数组中，有两种数出现了奇数次，其他数出现了偶数次，找出这两个奇数次的数A,B。   
```CPP
int eor=0;
for(int i=0;,i<len;,i++)
{
  eor ^= arr[i];
}
// eor = A^B
int rightone = err &( ~err +1);
int onlyone = 0;
for(:)//省略不写
{
    if( (arr[i] & rightone) !=0 )
        onlyone ^= arr[i];
}

A = eor ^ onlyone;
B= onlyone;
```
4. 找出一个数中二进制1的个数：
```cpp
int count = 0;
while(N!=0)
{
    int rightone = N & (~N + 1);
    count++;
    N ^= rightone; //每次抹掉最右侧的1. 这么做避免了循环32位int。
}
return count;
```

* 链表
1. 反转链表：

* 队列
1. 用数组实现队列，只需要增加多一个size变量，就可以不用管头尾指针追不追赶的问题。

* 栈
1. 找出目前栈中最小的值。 构建2个栈，一个栈放普通元素，另一个栈专门放最小值元素。push进来一个元素，判断当前的元素是否小于等于目前栈顶元素，是的话，同时压入两个栈，不是的话，第二个栈压入目前最小值。  
出栈的时候，两个栈同步出，只不过最小栈的元素不需要返回给用户。


* 求字符串中字母出现的最后位置
```cpp
#include <string>
string s;
int last[26];
int length = s.size();

for (int i = 0 ; i < length ; i++){
    last[s[i]-'a']=i;  // 某字母最后出现的下标为i; 一共26个小写字母；以'a'字母为0；当前字母s[i]在last的位置为:s[i]-'a'
}
```

* ++a与a++
```
这里我们使用了 ++ 和--的小技巧： a++ 和 ++a 都是将 a 加 1，但是 a++ 返回值为 a，而
++a 返回值为 a+1。**如果只是希望增加 a 的值，而不需要返回值，则推荐使用 ++a，其运行速度
会略快一些。**
```


