* int的范围 10位十进制数  
C语言[int](https://blog.csdn.net/weixin_30508241/article/details/99494703?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&utm_relevant_index=1)的取值范围在32/64位系统中都是32位，范围为-2147483648~+2147483647，2^31，1位符号位。可表达10^9  
无符号情况下表示为0~4294967295.无符号可表示2^32.

* long long 的范围 20位10进制数  
64位，2^63，1位符号位； 2^64无符号

* 强制类型转换
强制类型转换的格式为：`(type_name) expression`  
```cpp
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
```

-------------------------------------------
### 位操作
这些位运算的计算都是以补码的方式进行的, 因为计算机底层都是以补码进行计算的。  
原码取反-->反码， 反码+1-->补码， 补码-1--->反码， 反码取反--->原码。  

* 不用临时变量交换两个数
```cpp
//前提是你已经知道这两个变量的准确值
int a=1, b=2;
a ^= b;// a = 1^2;
b ^= a;// b = 2^1^2;
a ^= b;// a = 1^2^2^1^2;
```

* 与操作
应用场合：
1. 取一个整数中二进制的最右侧的1。：N &（ ~N +1 ）**经常用到**，等价于N&(-N)， -N在计算机中采用补码形式（除了符号位，其他取反，然后+1）
 
 
* 异或满足交换律，结合律等。 
应用场合： 
1. 不开辟新变量交换两个变量，缺点，但这两个变量在内存上是同一地址，失效。
2. 一个数组中，只有一种数出现了奇数次，其他数出现了偶数次，找出这个奇数次的数。对数组每个元素进行异或。
3. 一个数组中，有两种数出现了奇数次，其他数出现了偶数次，找出这两个奇数次的数A,B。   
```CPP
int eor=0;
for(int i=0;,i<len;,i++)
{
  eor ^= arr[i];
}
// eor = A^B
int rightone = err &( ~err +1);
int onlyone = 0;
for(:)//省略不写
{
    if( (arr[i] & rightone) !=0 )
        onlyone ^= arr[i];
}

A = eor ^ onlyone;
B= onlyone;
```
4. 找出一个数中二进制1的个数：
```cpp
int count = 0;
while(N!=0)
{
    int rightone = N & (~N + 1);// 取一个整数中二进制的最右侧的1
    count++;
    N ^= rightone; //每次抹掉最右侧的1. 这么做避免了循环32位int。
}
return count;
```
第二种解法
```cpp
int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);//直接消除最后一个 1
        res++;
    }
    return res;
}
```
5、判断一个数是不是 2 的指数  
一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：  
```CPP
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
//因此，将最后一个1去掉，如果是2的指数，那么结果肯定=0.
boolean isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```



-------------------------------------
* 链表
1. 反转链表：

* 队列
1. 用数组实现队列，只需要增加多一个size变量，就可以不用管头尾指针追不追赶的问题。

* 栈
1. 找出目前栈中最小的值。 构建2个栈，一个栈放普通元素，另一个栈专门放最小值元素。push进来一个元素，判断当前的元素是否小于等于目前栈顶元素，是的话，同时压入两个栈，不是的话，第二个栈压入目前最小值。  
出栈的时候，两个栈同步出，只不过最小栈的元素不需要返回给用户。


* 求字符串中字母出现的最后位置
```cpp
#include <string>
string s;
int last[26];
int length = s.size();

for (int i = 0 ; i < length ; i++){
    last[s[i]-'a']=i;  // 某字母最后出现的下标为i; 一共26个小写字母；以'a'字母为0；当前字母s[i]在last的位置为:s[i]-'a'
}
```

* ++a与a++
```
这里我们使用了 ++ 和--的小技巧： a++ 和 ++a 都是将 a 加 1，但是 a++ 返回值为 a，而
++a 返回值为 a+1。**如果只是希望增加 a 的值，而不需要返回值，则推荐使用 ++a，其运行速度
会略快一些。**
```

* 普及字符哈希：  
**因为构建哈希表比较费时，可以做如下优化**  
因为小写字母对应ASCII码，因此字典一般是这样{字母-频率}{a：2}，由于ASCII码，可以变为{a的ASCII码：2}，此时的key就变味了数字，  
所以就有了字符哈希，采用数组的形式，数组下标就是对应的key，也就是字母，数组的值就是对应的value，也就是该字母出现的频率。  
可以使用更简单的数组数据结构来存储频率，而不是仅使用特殊的哈希表数据结构来存储字符出现的频率。  
给定字符串仅包含小写字母（'a'到'z'）。因此我们需要采用大小为 26 的数组。其余过程与最后一种方法保持一致。  
```cpp
string s1;
unordered_map<char,int> cnt1;
vector<int> cnt(26);

//哈希表方法
for(char c: s1){
    ++cnt1[c];
}
//字符哈希方法
for(int i =0; i<26;i++){
   ++cnt[s1[i]-'a'] ;//键就是s1某字母的ascii码值， 值就是字母出现的次数。
}
```



