## C++

1. vector<T> 的使用   
[vector](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)有begin()、end()、size()、empty()成员  

```cpp
对vector的头尾添加零元素：
vector<int> v;
v.insert(v.begin(),0);
v.push_back(0);

用已有的数值初始化vector:
vector<int> a{1,2,3};
return vector<int>{1,2,3};
  
构造函数：
vector（）：创建一个空的vector。
vector（itn nSize）：创建一个vector，元素个数为nSize。
vector（int nSize， const T& t）：创建一个vector，元素个数为nSize，且值均为t。
vector（const vector&）：拷贝构造函数。
```
  
2. std、algorithm的使用  
[对数组求和](https://blog.csdn.net/qq_21567767/article/details/82023752)： std::accumulate(头指针，尾指针，0);  
*[max_element](https://blog.csdn.net/qq_44017078/article/details/111658628)* 注意返回的是地址    
```cpp
#include <algorithm>
/*
param begin : 序列起始地址（迭代器）
param end  : 序列结束地址（迭代器）
return   : 序列中最小元素地址（迭代器）
*/
min_element(begin, end);
  
/*
param begin : 序列起始地址（迭代器）
param end  : 序列结束地址（迭代器）
return   : 序列中最大元素地址（迭代器）
*/
max_element(begin, end);
```
  
3. sort()的使用  
[sort()](https://www.cnblogs.com/stones-dream/p/10183210.html) sort(头指针，尾指针，0)；  默认0为升序。
  
4. is_sorted()的使用  
[is_sorted()](http://m.biancheng.net/view/7478.html) ，is_sorted(头指针，尾指针)，默认是检查升序排序。

5. 指针与常量
```cpp
int x;
int *p1 = &x; //p1是指针，指针可以被修改，值页可以被修改
const int *p2 = &x;//p2是指针，指向const int, 指针可以被修改，值不可以被修改
int * const p3 = &x;//p3是const指针，指向int，指针不可以被修改，值可以被修改
const int * const p4 = &x;//p4是const指针，指向const int, 指针不可以被修改，值不可以被修改
```
6. 指针函数与函数指针
```cpp
//addition是指针函数，一个返回类型是指针的函数，只是一个函数，只是返回类型是一个指针
int* addition(int a , int b){
  int* sum = new int(a+b);//初始化一个int值：a+b ， 将存放这个值的地址赋给sum。
  return sum;
}

int subtraction(int a , int b ){
   return a-b;  
}
 
int operation(int x, int y, int (*func)(int ,int)){
  return (*func)(x,y);  
}
  
//minus是函数指针，指向函数的指针
int (*minus)(int, int) = subtraction; 
int* m =addition(1, 2); //m是一个指针，*m 表示指向的值
int n = operation(3, *m, minus);
```
  
```
  关于int* a = new int(10); 和  int a[10] 
　　1、如果只是int a[10]和int* a=new int[10]比较的话，前者可能还更简单一点。只是在使用上int* a=new int[10]需要判断内存是否分配成功，以及在不用时需要使用delete[] a进行内存释放；
　　2、如果不是a[10]，而是a[1000000000]或者更大的话，那一般情况下，就只能使用int* a=new这种方式了。这个涉及到内存存放位置的问题，int a[]这种方式，内存是存放在栈上；int* a＝new这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；
　　3、使用int a[10]这种方式，内存大小需要用常量指定，比如这里的10。不能用int m＝10；int a[m]这种方式。但是int* a= new这种方式可以，因此在动态分配内存上，后者有非常大的优势。
```
  
7. lambda函数表达式  
[lambda](https://www.cnblogs.com/jimodetiantang/p/9016826.html)
```cpp
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  } // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  } // 没有参数，仅访问某个全局变量
[] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)
```
