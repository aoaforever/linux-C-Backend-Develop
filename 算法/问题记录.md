## C++

1. vector<T> 的使用   
[vector](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)有begin()、end()、size()、empty()成员  

```cpp
对vector的头尾添加零元素：
vector<int> v;
v.insert(v.begin(),0);
v.push_back(0);

用已有的数值初始化vector:
vector<int> a{1,2,3};
return vector<int>{1,2,3};
  
构造函数：
vector（）：创建一个空的vector。
vector（itn nSize）：创建一个vector，元素个数为nSize。
vector（int nSize， const T& t）：创建一个vector，元素个数为nSize，且值均为t。
vector（const vector&）：拷贝构造函数。
```
  
2. std、algorithm的使用  
[对数组求和](https://blog.csdn.net/qq_21567767/article/details/82023752)： std::accumulate(头指针，尾指针，0);  
*[max_element](https://blog.csdn.net/qq_44017078/article/details/111658628)* 注意返回的是地址    
```cpp
#include <algorithm>
/*
param begin : 序列起始地址（迭代器）
param end  : 序列结束地址（迭代器）
return   : 序列中最小元素地址（迭代器）
*/
min_element(begin, end);
  
/*
param begin : 序列起始地址（迭代器）
param end  : 序列结束地址（迭代器）
return   : 序列中最大元素地址（迭代器）
*/
max_element(begin, end);
```
  
3. sort()的使用  
[sort()](https://www.cnblogs.com/stones-dream/p/10183210.html) sort(头指针，尾指针，0)；  默认0为升序。
```CPP
    vector<int> a{2,3,21,4,52,3,5,6,3,876,45,6,32,45};
    sort(a.begin(),a.end());//默认升序2 3 3 3 4 5 6 6 21 32 45 45 52 876
    sort(a.begin(),a.end(),[](int &a, int &b){
        return a>b;
    });//lambda函数降序876 52 45 45 32 21 6 6 5 4 3 3 3 2 
```

  
4. is_sorted()的使用  
[is_sorted()](http://m.biancheng.net/view/7478.html) ，is_sorted(头指针，尾指针)，默认是检查升序排序。

5. 指针与常量
```cpp
int x;
int *p1 = &x; //p1是指针，指针可以被修改，值页可以被修改
const int *p2 = &x;//p2是指针，指向const int, 指针可以被修改，值不可以被修改
int * const p3 = &x;//p3是const指针，指向int，指针不可以被修改，值可以被修改
const int * const p4 = &x;//p4是const指针，指向const int, 指针不可以被修改，值不可以被修改
```
6. 指针函数与函数指针
```cpp
//addition是指针函数，一个返回类型是指针的函数，只是一个函数，只是返回类型是一个指针
int* addition(int a , int b){
  int* sum = new int(a+b);//初始化一个int值：a+b ， 将存放这个值的地址赋给sum。
  return sum;
}

int subtraction(int a , int b ){
   return a-b;  
}
 
int operation(int x, int y, int (*func)(int ,int)){
  return (*func)(x,y);  
}
  
//minus是函数指针，指向函数的指针
int (*minus)(int, int) = subtraction; 
int* m =addition(1, 2); //m是一个指针，*m 表示指向的值
int n = operation(3, *m, minus);
```
  
```
  关于int* a = new int(10); 和  int a[10] 
　　1、如果只是int a[10]和int* a=new int[10]比较的话，前者可能还更简单一点。只是在使用上int* a=new int[10]需要判断内存是否分配成功，以及在不用时需要使用delete[] a进行内存释放；
　　2、如果不是a[10]，而是a[1000000000]或者更大的话，那一般情况下，就只能使用int* a=new这种方式了。这个涉及到内存存放位置的问题，int a[]这种方式，内存是存放在栈上；int* a＝new这种方式，内存是存放在堆上，栈的实际内存是连续内存，因此可分配空间较小，堆可以是非连续内存，因此可以分配较大内存。因此，如果需要分配较大内存，需要分配在堆上；
　　3、使用int a[10]这种方式，内存大小需要用常量指定，比如这里的10。不能用int m＝10；int a[m]这种方式。但是int* a= new这种方式可以，因此在动态分配内存上，后者有非常大的优势。
```
  
7. lambda函数表达式  
[lambda](https://www.cnblogs.com/jimodetiantang/p/9016826.html)
```cpp
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  } // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  } // 没有参数，仅访问某个全局变量
[] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数)
```
  
8. map、unordered_map的使用  
[unordered_map](https://blog.csdn.net/qq_21997625/article/details/84672775)  
map底层是红黑树，插入元素的时候自动排序；  
unordered_map底层是哈希表，不排序，但是查找时间复杂度为O(1)  
由于unordered_map不允许存储具有重复键的元素，因此count()函数本质上检查unordered_map中是否存在具有给定键的元素。  
可以使⽤⽅括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会⾃动创建这个key，并把 map[key] 赋值为 0。  
```cpp
#include <map>
#include <unordered_map>
//常用方法：
.insert();
.find();
.begin();
.end();
.count();
.size();
  
//判断某个键在不在哈希表中
if (map.find(key)!=map.end()){
  //do something
  }
if (map.count(key)){
  //返回1表示键在哈希表中
  }
  
//更新某个键的值.
map[key]++;
  
```

9. string类的使用  
[string](https://www.jb51.net/article/41725.htm)  
```cpp
#include <string>
string a;
a.append();//追加字符
a.push_back();//追加字符
a += "something";//追加字符
a.size();//返回字符数量，不包括'\0'
a.empty();//判断是否为空
```
  
10. queue队列的使用(14优先队列)  
[queue](http://c.biancheng.net/view/479.html) 不能遍历！！！！
```cpp
#include<queue>
queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：
front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
push(const T& obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。
push(T&& obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。
pop()：删除 queue 中的第一个元素。
size()：返回 queue 中元素的个数。
empty()：如果 queue 中没有元素的话，返回 true。
emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。
swap(queue<T> &other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。
  
//例子
T abc,edf,gfd;
queue<T> q;
q.push(abc);
q.push(edf);
q.push(gfd);
  
//获取队头元素
while(!q.empty()){
  auto node = q.front();
  q.pop();
  }
  
```
11. pair键值对的使用  
[pair](https://www.cnblogs.com/lvmf/p/10777261.html)
  
12. to_string()的使用  
[to_string](https://blog.csdn.net/qq_18815817/article/details/82431685) 能够将整型转换为string类型。  

13. greater与less  
```CPP
//less的定义
template <class T>
struct less{//less小于，体现在x<y
  bool operator()(const T& x, const T& y){ return x<y; } //在sort中就是升序，在优先队列中就是先输出大的值
  //...还有三行省略
  };
                                                       
//greater的定义
template <class T>
struct greater{//greater大于，体现在x>y
  bool operator()(const T& x, const T& y){ return x>y; } //在sort中就是降序，在优先队列中就是先输出小的值
  //...还有三行省略
  };
```

14. 优先队列priority_queue(10队列)  
[priority_queue](https://www.cnblogs.com/huashanqingzhu/p/11040390.html)  
```CPP
#include <queue>
priority_queue q;//默认是less，但是队头是最大值排序
q.top();//返回顶部元素
q.push();//压入
q.pop();//弹出
//如果要使用自定义排序，则应该写一个排序结构体，里面重定义()操作符。
{
    vector<int> a{2,3,21,4,52,3,5,6,3,876,45,6,32,45};
    struct cmp{
        bool operator()(const pair<int,int>&a, pair<int,int>&b){
            return a.second<b.second;//升序，less，队头为最大值
        }
    };
    priority_queue<int> pq;
    priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> qq;

    for(int i = 0 ; i <a.size();i++){
        // cout<<i<<" ";
        pair<int,int> c{i,a[i]};
        // pq.push(i);
        qq.push(c);
    }

    // while(!pq.empty()){
    //     int c = pq.top();
    //     pq.pop();
    //     cout<<c<<" ";
    // }

    while(!qq.empty()){
        pair<int,int> c = qq.top();
        qq.pop();
        cout<<c.first<<" "<<c.second<<", ";
    }
}
```
  
15. list双端链表的使用  
[list](https://blog.csdn.net/yas12345678/article/details/52601578/)
```cpp
#include <list>
list<int> l1;  
l1.push_back();//从尾端插入节点
l1.push_front();//从头部插入节点
l1.front();//获取头部元素
l1.back();//获取尾部元素

//list中的构造函数：  
list() 声明一个空列表；
list(n) 声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的
list(n,val) 声明一个由n个元素的列表，每个元素都是由其复制构造函数T(val)得来的
```
